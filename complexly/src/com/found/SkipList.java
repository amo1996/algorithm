package com.found;


/**
 * 跳表：可以迟滞快速的插入、删除、查找。
 * 是根据链表的改造。
 */
public class SkipList {
    /**
     *  建立N级索引
       我们可以隔2个或者3个或者N个节点提取一个节点到上一级，我们把抽出来的哪一级叫作索引层。
     我们可以加很多级索引。

       用跳表查询到底有多快？
     在一个单链表中查询某个数据的时间复杂度是O(n)。
     跳表中查询任意数据的时间复杂度是O(logn)。跟二分查找是一样的。
     但是前提是建立了很多级索引，也就是空间换时间的设计思路。

      跳表索引动态更新：
     当我们不停的往跳表中插入数据时，如果不更新索引，就可能会出现某2个索引节点之间数据非常多。
     极端情况下，跳表还会退化成单链表。

     所以，当我们往跳表中插入数据的时候，可以选择同时将这个数据插入到部分索引层中。
     我们可以通过一个随机函数，来决定将这个节点插入到哪几级索引层，比如函数生成了值K，
     那我们就将这个节点添加到第一级到第K级 这K级索引中。

     所以随机函数的选择就很重要了。要从概率上保证跳表的索引大小和数据大小的平衡性。

     那为什么redis要用跳表来实现有序集合(sort List)，而不用红黑树？
     答：redis中的有序集合支持的核心操作主要有下面这几个：
         1、插入一个数据;
         2、删除一个数据;
         3、查找一个数据;
         4、按照区间查找数据;
         5、迭代输出有序序列;
     其中，插入、删除、查找以及迭代输出这几个操作，红黑树也可以完成，时间复杂度和跳表是一样的。
      但是，按照区间查找数据，红黑树的效率没有跳表高。
     跳表可以做到O(logn)的时间复杂度定位区间的七点，然后在原始链表中顺序往后遍历即可。
     还有其他原因，比如跳表更容易代码实现，红黑树过于复杂。
     跳表更加灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。
     但是跳表在API中没有现成的实现，在开发中，需要自己去实现。


     */


}
