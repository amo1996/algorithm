 为什么散列表和链表经常一块使用？

散列表支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。
无法支持按照某种顺序快速的遍历数据。如果希望按照顺序遍历散列表中的数据，就需要将散列表中的数据拷贝到数组中，然后排序，再遍历。
但是散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历列表中的数据的时候，都需要先排序，效率很低。
为了解决这个问题，我们可以将散列表和链表（或者跳表）结合在一起使用。


一、LRU缓存淘汰算法
  单独用链表实现的LRU缓存淘汰算法的时间复杂度是O(N).可以通过散列表将时间复杂度降低到O(1).

  一个缓存系统主要包含下面这几个操作：
  ·往缓存中添加一个数据;
  ·从缓存中删除一个数据;
  ·在缓存中查找一个数据;

1、通过链表实现LRU缓存淘汰算法：
   我们需要维护一个按照访问时间有序排序的链表结构。因为缓存空间有限，当空间不够，需要淘汰一个数据的时候，我们就直接将链表头部的节点删除。
当需要缓存某个数据的时候，现在链表中查找这个数据，如果没有找到，则直接将数据放到链表的尾部;如果找到了，我们就把它移动到链表的尾部。
因为查找数据需要遍历链表，所以单纯用链表实现的LRU缓存淘汰算法的时间复杂度是O(N),

添加、删除、查找都要涉及到"查找"操作，如果单纯使用链表的话，时间复杂度只能是O(N).如果结合散列表和链表两种数据结构，可以降低到O(1)。

2、散列表和链表组合实现LRU缓存淘汰算法：
 我们使用双向链表存储数据，链表的每个结点有存储数据(data)、前驱指针(prev)、后继指针(next)、还有一个hnext。
 因为我们的散列表本身是通过链表法来解决散列冲突的，所以每个结点还需要保存散列表的拉链指针。
 前驱和后继指针是为了将结点串在双向链表中，hnext是为了将结点串在散列表的拉链中。

 这时，我们查找一个数据，通过散列表，可以很快的在缓存中找到一个数据，当找到数据之后，我们还需要将它移动到双向链表的尾部。
 删除一个数据，我们需要找到数据所在的结点，然后将结点删除。通过散列表，我们可以在O(1)时间复杂度里找到要删除的结点。
 而且，双向链表可以通过前驱指针获取前驱结点，所以在双向链表中，删除结点也只需要O(1)的时间复杂度。
 添加一个数据，我们需要先看这个数据是否已经在缓存中。如果在其中，需要将其移动到双向链表的尾部;如果不在，要看缓存满没有满。如果满了，
 则将双向链表头部的结点删除，然后将数据放到链表的尾部，如果没满，直接将数据放到链表的尾部。


 二、redis的有序集合(sort set)
  在redis的有序集合里面，有两个非常重要的属性，key(键值)和 score(分值).可以通过score来排序，查找区间数据。
  但是如果仅仅按照分值将数据组织成跳表的结构，那按照键值来删除、查询就会很慢。解决方法和LRU有点类似。
  我们可以按照键值构建一个散列表，按照分值构建一个跳表。


 三、LinkedHashMap(散列表和链表)
   通过双向链表和散列表组合实现的，Linked实际上是指的双向链表，并非指用链表法解决散列冲突。

 HashMap<Integer,Integer> m=new LinkedHashMap<>();
 m.put(3,11);
 m.put(1,12);
 m.put(5,23);
 m.put(2,22);

 for(Map.Entry e : m.entrySet()){
  System.out.println(e,getKey());
 }

 上面的代码会按照数据插入的顺序依次来打印，也就是3,1,5,2.
 散列表是经过散列函数打乱无规律存储的，LinkedHashMap是按照数据的插入顺序。

 LinkedHashMap不仅支持按照插入顺序遍历数据，还支持按照访问顺序来遍历数据。
 //10是初始大小,0.75f是装载因子，true表示按照访问时间排序
 HashMap<Integer,Integer> m=new LinkedHashMap<>(10,0.75f，true);
 m.put(3,11);
 m.put(1,12);
 m.put(5,23);
 m.put(2,22);

 m.put(3,26);
 m.get(5);

 for(Map.Entry e : m.entrySet()){
  System.out.println(e,getKey());
 }

上面这段代码结果是1,2,3,5.

调用put()函数往LinkedHashMap中添加数据的时候，将数据添加到链表的尾部，所以再次将键值为3的数据放入到LinkedHashMap的时候，
会先查找这个键值是否已经存在，然后将已经存在的(3,11)先删除，再将新的(3,26)放到链表的尾部。
当使用get访问到key为5的数据的时候，我们将被访问到的数据移动到链表的尾部，所以最后打印出来的是1,2,3,5.

这种按照访问时间排序的LinkedHashMap本身就是一个支持LRU缓存淘汰策略的缓存系统。

