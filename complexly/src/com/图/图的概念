微博中，两个人可以互相关注;微信中，两个人可以互加好友。如果存储这种社交网络的好友关系?


 一、图:
   图也是一种非线性表数据结构。
   图中的元素我们叫作顶点(vertex)。图中的一个顶点可以与任意其他顶点建立连接关系。这种建立的关系叫作边。

      无向图:边没有方向的图
   所以，微信的好友关系就可以用一张图来表示，如果两个用户之间互为好友，就在两者之间建立一条边。
   其中，每个用户有多少个好友，对应到图中，就叫作顶点的度，就是跟顶点相连接的边的条数。

      有向图:边有方向的图
    微博中，如果用户A关注了用户B，就在图中画一条从A到B的带箭头的边，来表示边的方向。
    如果用户A和用户B互相关注了，就画一条从A指向B的边，再画一条从B指向A的边。
    在有向图中，我们把度分为入度(In-degree)和出度(Out-degree)。
    入度:有多少条边指向这个顶点     出度:有多少条边是以这个顶点为起点指向其他顶点。

      带权图:每条边都有一个权重。
      QQ中，QQ亲密度记录了用户之间的好友关系程度。

 二、图的存储:
   1.邻接矩阵(Adjacency Matrix):
     底层是一个二维数组，对于无向图来说，如果顶点i与顶点j之间有边，我们就将A[i][j]和A[j][i]都标记为1;
     对于有向图来说，如果顶点i到顶点j之间，有一条箭头从顶点i指向顶点j的边，那我们就将A[i][j]标记为1.
     如果有一条箭头从顶点j指向顶点i的边，我们就将A[j][i]标记为1.
     对于带权图，数组中就不标记为1，就标记为相应的权重。

     缺点:
     1.比较浪费存储空间。
       对于无向图来说，如果A[i][j]=1 那么A[j][i]肯定也等于1，只需要存储一个就可以了。另一半等于浪费掉了。
       如果存储的是稀疏图(Sparse Matrix)，就是顶点很多，但是每个顶点的边并不多，就更加浪费空间了。

     优点:
     1.存储方式简单、直接，因为基于数组，所以在获取两个顶点的关系，很高效。
     2.方便计算，可以将很多图的运算转换成矩阵之间的运算。

   2.邻接表(Adjacency List):
     每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。
     存储起来比较节省空间，但是使用起来就比较耗费时间。
     如果要确定是否存在一条从顶点A到顶点B的边，我们就要遍历顶点A对应的那条链表是否存在顶点B。
     而且链表的存储方式对缓存不友好。

     在散列表中，基于链表法解决散列冲突的散列表中，如果链表过长，为了提高查找效率，我们可以将链表换成其他更加高效的数据结构。

     这里，可以将邻接表中的链表改成红黑树，可以快速的查找两个顶点之间是否存在边了。
     还可以将链表改成有序动态数组，通过二分查找的方法来快速定位两个顶点是否存在边。


   微博:
     ·判断用户A是否关注了用户B
     ·判断用户A是否是用户B的粉丝
     ·用户A关注用户B
     ·用户A取消关注用户B
     ·根据用户名称的首字母排序,分页获取用户的粉丝列表;
     ·根据用户名称的首字母排序,分页获取用户的关注列表;

     首先因为社交网络是一张稀疏图，采用邻接表来存储。
     用一个邻接表来存储这种有向图，去查找某个用户关注了哪些用户非常容易。
     但是想知道某个用户被那些用户关注了，也就是用户的粉丝列表，非常困难。
     我们需要一个逆邻接表。存储的用户的被关注关系。
     每个顶点对应的链表中，存储的就是指向这个顶点的顶点。
     但是也不适合快速判断两个用户之间是否是关注与被关注的关系。
     可以改成红黑树或者跳表，根据实际情况选择。
