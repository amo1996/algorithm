为了加速数据库中数据的查找速度，我们常用的思路是对表中数据创建索引。

一、索引是如何实现的呢？
 1.为了让二叉查找树支持按照区间来查找数据，我们可以进行改造:
    树中的节点并不存储数据本身，而是作为索引。
    每个叶子节点串在一条链表上，链表中的数据都是从小到大有序的。

  这时候，如果我们要求某个区间的数据，只需要拿区间的骑士值，在树中进行查找，
  当查找到某个叶子节点之后，我们再顺着链表往后遍历。

  问题:如果要为上亿的数据构建索引，如果将索引存储在内存中，很多表的话，内存的需求无法满足。
   我们可以借助时间换空间的思路，把索引存储在硬盘中，而非内存中。
   尽管减少了内存消耗，但是在数据查找的过程中，需要读取磁盘中的索引，因此数据查询效率就相应降低很多。
   每个节点的访问，都对应一次磁盘IO操作，树的高度就等于每次查询数据时磁盘IO操作的次数。
   优化的重点就是尽量减少磁盘IO操作，也就是，尽量降低树的高度。
   方法就是把索引构建成m叉树，对于相同个数的数据构建m叉树索引，m越大，那树的高度就越小。
   但也不是越大越好。
   不管是内存中的数据，还是磁盘中的数据，操作系统都是按页(一页大小通常是4KB,可以通过 getconfig PAGE_SIZE命令查看)来读取的。
   一次会读一页的数据，如果要读取的数据量超过一页的大小，就会触发多次IO操作，所以，在选择m大小的时候，尽量让每个节点的大小等于一个页的大小。
   这样读取一个节点，只需要一次磁盘IO操作。

  索引的坏处:
   会让写入数据的效率下降。
   写入过程，会涉及到索引的更新，这是索引导致写入变慢的主要原因。
   对于一个B+树，m值是根据页的大小事先计算好的，每个节点最多只能有m个子节点。
   在数据写入过程中，可能使索引中某些节点的子节点个数超过m，这个节点的大小就超过了一个页的大小。

   这时候，只需要将这个节点分裂成两个节点，但是节点分裂之后，其上层父节点的子节点个数就有可能超过m个。
   我们可以用同样的办法，将父节点也分裂成两个节点，一直到根节点。

   删除某个数据的时候，也要更新对应的索引节点，如果频繁的数据删除，可能导致某些节点中，子节点的个数非常少。
   我们可以设置一个阀值，在B+树中，这个阀值等于m/2，如果某个节点的子节点个数小于m/2，我们就将它与相邻的兄弟节点合并。
   合并之后，如果子节点个数超过m。就根据插入数据的处理方法，再分裂节点。

  总结:
  ·数据库索引底层依赖的数据结构是  B+树。通过存储在磁盘的多叉树结构，做到了时间、空间的平衡。
   B+树的特点:
    ·每个节点中子节点的个数不能超过m，也不能小于m/2.
    ·根节点的子节点个数可以不超过m/2，这是特殊.
    ·m叉树只存储索引，并不真正存储数据，有点类似跳表.
    ·通过链表将叶子节点串联在一起，方便按区间查找.
    ·一般根节点存储在内存中，其他节点存储在磁盘中.
   B-树其实就是B树，翻译是B-Tree  这里"-"不是相对B+树中的"+"，而是一个连接符。
   B树又是低级版的B+树:
   ·B+树中的节点不存储数据，只是索引，而B树中的节点存储的是数据;
   ·B树中的叶子节点不需要链表来串联，B+树需要。
   所以B树只是每个节点的子节点个数不能小于m/2的m叉树。
