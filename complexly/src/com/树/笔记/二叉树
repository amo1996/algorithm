二叉树有哪几种存储方式？什么样的二叉树适合用数组来存储？
既可以用链式存储，也可以用数组顺序存储。
数组顺序存储适合完全二叉树，不会太浪费存储空间

一、树（Tree）：
 "树"这种数据结构很像现实生活中的"树"，每个元素我们叫作"节点";用来连线相邻节点之间的关系，叫作"父子关系"。

 父节点是同一个节点的，互称为兄弟节点，没有父节点的节点叫作根节点。没有子节点的节点叫作叶子节点或者叶节点。
 还有高度(Height)、深度(Depth)、层(Level)

  节点的高度=节点到叶子节点的最长路径(边数);
  节点的深度=根节点到这个节点所经历的边个个数;
  节点的层数=节点的深度+1;
  树的高度=根节点的高度;

  高度是从下往上度量，深度是从上往下度量，层数是从根节点开始度量。
  高度和深度计数起点是0,层数的计数起点 是1，也就是根节点是位于第1层。


二、二叉树(Binary Tree)：

    二叉树每个节点最多有两个"分叉"，也就是两个子节点，分别是左子节点和右子节点。
  而且不要求每个节点都有两个子节点。

    满二叉树：叶子节点全在最底层，除了叶子节点之外，每个节点都有左右子节点。

    完全二叉树：除了最后一层，其它层的节点个数都要达到最大，而且最后一层的叶子节点都从左排列满。

    如何存储一颗二叉树？
    1.基于指针或者引用的二叉链式存储法
    每个节点有三个字段，一个存储数据，两个指向左右子节点的指针。
    2.基于数组的顺序存储法
    根节点存储在下标i=1的位置，左子节点存储在下标2*i=2的位置，右子节点存储在2*i+1=3的位置。
    完全二叉树只浪费了一个下标为0的存储位置，如果是非完全二叉树，就有可能会浪费比较多的数组存储空间。
    所以完全二叉树用数组存储最节省内存，不用存储额外的左右子节点的指针。

  三、二叉树的遍历：
   1.前序遍历:对于树中的任意节点来说，先打印这个节点，再打印左子树，最后打印右子树。
      preOrder(Node root){
       if(root==null) return ;
       print root;
       preOrder(root->left);
       preOrder(root->right);
     }
   2.中序遍历:对于树中的任意节点来说，先打印它的左子树，再打印它本身，最后打印右子树。
           inOrder(Node root){
            if(root==null) return ;
            inOrder(root->left);
            print root;
            inOrder(root->right);
          }
   3.后序遍历:对于树中的任意节点来说，先打印左子树，再打印右子树，最后打印它本身。
          postOrder(Node root){
               if(root==null) return ;
               postOrder(root->left);
               postOrder(root->right);
               print root;
             }
   其实这里的前、中、后表示的节点与它的左右子节点遍历打印的先后顺序，
   前序就是先打印自己，中就是在中间打印，后就是最后打印自己。
   要注意：打印子树的意思是递归先打印最底层的叶子节点。

   可以得出，每个节点最多被访问两次，所以遍历操作的时间复杂度与节点的个数n成正比，时间复杂度是O(N).

 四、二叉查找树(Binary Search Tree):
  特点：支持动态数据集合的快速插入、删除、查找操作。
  散列表也支持这些操作，时间复杂度还是O(1)，那为什么还需要二叉树呢？
   1.散列表中的数据时无序存储的，如果要输出有序的数据，需要先排序。而对于二叉查找树，只需要中序遍历即可。
   2.散列表扩容耗时很多，而且遇到散列冲突时，性能不稳定，虽然二叉查找树性能也不稳定，但是，最常用的平衡二叉查找树的性能非常稳定。
   3.因为哈希冲突的存在，虽然散列表查找操作的时间复杂度是O(1)，但是实际上查找速度可能不一定比O(logN)快。
   加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。
   4.散列表的构造比二叉查找树要复制，需要考虑散列函数，冲突解决，扩容，缩容。
   平衡二叉查找树只需要考虑平衡性这个问题。而且解决方案比较成熟、固定。


  特殊结构:要求在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值。右子树节点的值都大于这个节点的值。

  1、查找：
   我们先取根节点，如果等于我们要查找的数据，那就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找;
   如果要查找的数据比根节点的值大，那就在右子树中递归查找。
    public class BinarySearchTree{
       private Node tree;

       public Node find(int data){
       Node p=tree;
       while(p!=null){
       if(data<p.data){
       p=p.left;
       }else if(data>p.data){
       p=p.right;
       }else{
       return p;
       }
       return null;
       }
}
  static Class Node{
  private int data;
  private Node left;
  private Node right;

  public Node(int data){
  this.data=data;
    }
   }
  }

   2.插入：
   新插入的数据一般都是在叶子节点上，所以只需要从根节点开始，依次比较要插入的数据和节点的大小关系。
   如果插入的数据比节点的数据大，并且右子树为空，就直接插到右子节点的位置，如果不为空，就再递归遍历右子树，
   查找插入位置。同理，左子树也是同样的情况。

   public void insert(int data){
   if(tree=null){
    tree=new Node(data);
    return ;
    }
    Node p=tree;
    while(p!=null){
    if(data>p.data){
    if(p.right==null){
    p.right=new Node(data);
     return ;
    }
    p=p.right;
    }else{
    if(p.left==null){
    p.left=new Node(data);
    return ;
    }
    p=p.left;
      }
     }
    }
    3.删除：
    针对要删除节点的子节点个数情况，来进行不同的处理：
    1.如果要删除的节点没有子节点，只需要直接将该节点的父节点中指向该删除节点的指针置为null。
    2.如果要删除的节点有一个子节点，只需要将该节点的父节点中指向要删除节点的指针，指向要删除节点的子节点即可。
    3.如果要删除的节点有两个子节点，我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。
    还可以单纯的将要删除的节点标记为"已删除"，但是并不真正从树中将这个节点去掉。
    这样只是浪费内存空间，但是删除操作就变的简单了不少。

  确定二叉树的高度：
  1.深度优先思想的递归：
    分别求左右子树的高度，当前节点的高度就是左右子树中较大的那个+1.
  2.层次遍历：


