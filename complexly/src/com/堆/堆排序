  堆是一种特殊的树。
   一、堆:(两点都满足才是堆)
     ·堆是一个完全二叉树
     ·堆中每一个节点的值都必须大于等于(或者小于等于)其子树中每个节点的值(注意是每个节点)

     完全二叉树:除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。
     对于每个节点的值大于等于子树中每个节点值的堆，叫作"大顶堆";
     对于每个节点的值小于等于子树中每个节点值的堆，叫作"小顶堆";

   二、如何实现一个堆:
     首先，完全二叉树比较适合用数组来存储，非常节省存储空间。不需要存储左右子节点的指针。
     数组中下标为i节点的左子节点，就是下标为i*2的节点，右子节点就是下标为i*2+1的节点。

     操作:(大顶堆为例)
     1.往堆插入一个元素:
       插入一个元素后，我们需要继续满足堆的两个特性。
       如果我们把新插入的元素放到堆的最后，我们就需要进行调整。
       这个过程被称为堆化(heapify).
       堆化:
       ·从下往上:
         顺着节点所在的路径，向上或者向下，对比，然后交换。
         新插入的节点与父节点对比大小，不满足子节点小于等于父节点，就互换两个节点。
         一直重复这个过程，直到父子节点满足大小关系。
         public class Heap{
          private int[] a;    //数组,从下标1开始存储数据;
          private int n;      //堆可以存储的最大数据个数;
          private int count;  //堆中已经存储的数据个数;

          public Heap(int capacity){
           a=new int[capacity+1];
           n=capacity;
           count=0;
          }

          public void insert(int data){
           if(count>=n)  return ;  // 堆满了;
           ++count;
           a[count]=data;
           int i=count;
           while(i/2>0&&a[i]>a[i/2]){   //自下往上堆化  i/2>0 : i不是根节点
            swap(a,i,i/2);  // 交换下标i和下标i/2的两个元素
            i=i/2;
          }


         }




     2.从堆删除堆顶元素:
     从堆的定义 任何节点的值都大于等于(或小于等于)子树节点的值，我们可以发现，堆顶元素存储的就是堆中数据的最大值或者最小值。

     假如我们直接删除堆顶元素，就需要把第二大的元素放到堆顶，这样最后堆化出来的堆可能会有数组空洞。
     不满足完全二叉树这个特性。
     我们可以把最后一个节点放到堆顶，这样就可以利用从上往下的推化比较父子节点。
     而且在堆化过程中，都是交换操作，不会出现数组中的空洞。最后肯定满足完全二叉树的特性。
     ·从上往下:
     public void removeMax(){
     if(count==0) return -1; //堆中没有数据了
     a[1]=a[count];
     --count;
     heapify(a,count,1); //堆化
   }
     private void heapify(int[] a,int n,int i){
     while(true){
     int maxPos=i;
     if(i*2<=n&&a[i]<a[i*2]) maxPos=i*2;   //如果当前节点小于左子节点  将左子节点的下标赋给maxPos;
     if(i*2+1<=n&&a[maxPos]<a[i*2+1]) maxPos=i*2+1;  //如果左子节点小于右子节点  将右子节点的下标赋给maxPos;
     if(maxPos==i) break;    //如果maxPos没变化，说明当前节点已经大于了左右子节点 结束堆化
     swap(a,i,maxPos);       //交换下标i和下标maxPos
     i=maxPos;               //将关注节点转移到交换后的节点
      }
     }

     堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比。

   三、堆排序:
    时间复杂度是O(nlogN).还是原地排序算法
    所谓原地:就是不借助另一个数组，就在原数组上操作。
    1.建堆:
     (1).利用在堆中插入一个元素。从前往后处理数组数据，从下往上堆化。
     我们可以假设，起始堆中只包含一个数据，就是下标为1的数据，然后我们调用前面的插入操作。
     将下标从2到n的数据依次插入到堆中，就组织成了堆。

     (2).从后往前处理数组,并且每个数据都是从上往下堆化
        private static void buildHeap(int[] a,int n){
         for(int i=n/2;i>=1;--i){
         heapify(a,n.i);
         }
         private static void heapify(int[] a,int n,int i){
         while(true){
             int maxPos=i;
              if(i*2<=n&&a[i]<a[i*2]) maxPos=i*2;   //如果当前节点小于左子节点  将左子节点的下标赋给maxPos;
              if(i*2+1<=n&&a[maxPos]<a[i*2+1]) maxPos=i*2+1;  //如果左子节点小于右子节点  将右子节点的下标赋给maxPos;
              if(maxPos==i) break;    //如果maxPos没变化，说明当前节点已经大于了左右子节点 结束堆化
              swap(a,i,maxPos);       //交换下标i和下标maxPos
              i=maxPos;               //将关注节点转移到交换后的节点

           }
         }

        }
    2.排序:
    建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的，第一个元素就是堆顶，也就是最大的元素。
    我们把堆顶元素和最后一个元素交换，那最大元素就放到了下标为n的位置上。
    这个过程有点类似上面删除堆顶元素的操作。
    再通过堆化的方法，将剩下的n-1个元素重新构建成堆。堆化完全之后，我们再取堆顶的元素，放到下标是n-1的位置。
    一直重复这个过程，直到堆中只剩下下标为1的一个元素，排序就完成了。
     //n表示数据的个数，数组a中的数据从下标1到n的位置
     public static void sort(int[] a,int n){
        buildHeap(a,n);
        int k=n;
        while(k>1){
        swap(a,1,k);
        --k;
        heapify(a,k,1);
        }
     }
     整个排序过程，只需要极个别临时存储空间，所以是原地排序算法。
     推排序不是稳定的排序算法，因为存在将堆的最后一个节点跟推顶节点互换的操作，就有可能改变相同数据的原始相对顺序。

     建堆过程的时间复杂度是O(N),排序过程的时间复杂度是O(nlogN).

     但是为什么快速排序要比堆排序性能好?
     1.推排序数据访问的方式没有快速排序好。
     对于快速排序，数据是顺序访问的，而对于堆排序，数据时跳着访问的。
     对推顶节点进行堆化的时候，会依次访问数组下标是1,2,4,8的元素。
     而不是像快速排序是局部顺序访问，所以这样对CPU缓存不友好。

     2.对于同样的数据，堆排序的数据交换次数要多于快速排序。
     堆排序第一步是建堆，会打乱数据原有的相对顺序。
     可能对于一组已经有序的数据来说，经过建堆之后，数据反而变的无序了。

