

/**
 * 哈希表/散列表   借助散列函数对数组这种数据结构进行扩展，利用了数组支持下标随机访问元素的特性。
 * 散列表的两个核心是散列函数设计和散列冲突解决，
 *  2019年6月21日15:29:35
 *  liZhi
 *
 */

    /**
     *     散列表：
     *  散列表利用数组支持按照下标随机访问，时间复杂度是O(1)的特性。
     * 我们通过散列函数把元素的键值映射成下标，然后将数据存储在数组中对应下标的位置。
     * 当我们按照键值去查询元素时，我们用同样的散列函数，将键值转化为数组下标，从对应的位置取数据即可。
     *
     *
     *    散列函数：
     *  hash(key); 其中key表示元素的键值， hash(key)表示经过散列函数计算得到的散列值。
     *  散列函数的基本要求：
     *  1、散列函数计算得到的散列值是一个非负整数;(因为数组下标是从0开始的)
     *  2、如果key1=key2;那么hash(key1)==hash(key2);
     *  3、如果key1不等于key2;那hash(key1)不等于hash(key2);
     *
     * 但是要找到一个完美的无冲突的散列函数不太现实，因为数组的存储空间有限，也会加大散列冲突的概率。
     *
     *
     *    散列冲突：
     *  散列冲突是无法避免的，常用的散列冲突解决方法有两种：
     *  1、开放寻址法(open addressing)：
     *  如果出现了散列冲突,我们就重新探测一个空闲位置，将其插入。
     *  1) 线性探测法：
     *  如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，直到找到插入为止。
     *  这种情况下查找元素的过程有点类似插入过程。
     *  我们通过散列函数找到散列值，然后比较数组中下标为散列值的元素和要查找的元素。
     *  如果相等，则说明就是我们要找的元素;否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没找到，就说明没有在散列表中。
     *  这种情况下的删除有些特别：
     *  我们可以将删除的元素，特殊标记为deleted。当线性探测查找的时候，遇到标记为deleted的空间，并不是停下来，而是继续探测。
     * 2) 二次探测：步长不同
     * 3) 双重散列：不仅使用一个散列函数，使用一组散列函数，先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，
     *    以此类推，直到找到空闲的存储位置。
     *
     *   不管使用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。
     *   为了保证散列表的操作效率，尽可能保证散列表中有一定比例的空闲位置，我们用装载因子表示空位的多少。
     *
     *   散列表的装载因子=填入表中的元素个数/散列表的长度
     *   装载因子越大，说明空闲位置越少，冲突越多。散列表的性能就会下降。
     *
     *  2、链表法(chaining)：
     *   每一个槽都会对应一条链表。
     *  当插入的时候，我们只需要计算对应的散列槽位，将其插入到对应的链表中即可。
     *  所以插入的时间复杂度是O(1)。
     *  当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。
     *  这两个操作的时间复杂度跟链表的长度K成正比，也就是O(k).
     *
     *  问题：word文档中单词拼写检查功能是如何实现的？
     *   答： 常用的英文单词有20万个左右，假设单词的平均长度是10个字母，平均一个单词占用10个字节的内存空间。
     *   那20万英文单词大约占用2MB的存储空间，对于现在的计算机来说，这个大小完全可以放在内存里面。
     *   所以我们可以使用散列表来存储整个英文单词词典。
     *
     *  当用户输入某个单词时，我们拿单词去散列表中查找，如果查到，就拼写正确。如果没有查到，就给予提示。
     *
     *
     * 1、   假设我们有10万条URL访问日志，如果按照访问次数给URL排序？
     *
     *  遍历10万条数据，以URL为key,访问次数为value,存入散列表，同时记录下访问次数的最大值K,时间复杂度O(N).
     *  如果K不是很大，就使用桶排序，时间复杂度为O(N).如果K非常大，就使用快速排序，时间复杂度为O(NlogN).
     *
     * 2、有两个字符串数组，每个数组大约有10万条字符串，如果快速找出两个数组中相同的字符串?
     *
     * 以第一个字符串数组构建散列表，key为字符串，value为出现次数。
     * 再遍历第二个字符串数组，以字符串为key在散列表中查找，如果value大于0，说明存在相同字符串。
     * 时间复杂度为O(N)。
     *
     */
